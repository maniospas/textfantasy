#ifndef UNIT_H
#define UNIT_H

#include <iostream>
#include <vector>
#include <cstdint>
#include <random>
#include <cmath> 
#include "utils.h"

class Terrain; // forward declaration
static const char* NO_SYMBOL = "  ";
using UnitProcess = void(*)(struct Unit* self, Terrain* terrain, long x, long y);
using ItemApply = void(*)(struct Unit* self, struct Unit* other);
using ItemDescripton = void(*)(struct Item* self);

struct Item {
    const char* name;
    const char* symbol;
    const char* description;
    long proficiency;
    ItemApply effect;
    uint8_t armor;
};

struct Unit {
    const char* name;
    const char* symbol;
    const char* effect;
    int8_t mood;

    uint8_t health;
    uint8_t max_health;
    uint8_t speed;
    uint8_t size;

    UnitProcess process;
    ItemApply spreads;

    uint8_t to_spread;
    uint8_t provisions;
    uint8_t materials;
    uint8_t stories;

    uint8_t money;
    uint8_t fame;
    uint8_t cycle;
    uint8_t frozen;

    struct Unit* ai_target;
    std::vector<Item> items;

    // Default constructor
    Unit()
        : name("Unknown"), symbol("  "), effect(nullptr),
        mood(0), health(5), max_health(5),
        speed(5), size(1),
        process(nullptr), spreads(), to_spread(0),
        provisions(0), materials(0), stories(0), money(0), fame(0),
        cycle(0), frozen(0),
        ai_target(nullptr)
    {}

    // Basic constructor ‚Äì starting health = max_health automatically
    Unit(const char* nm, const char* sym,
        long size_, long max_health_,
        long speed_,
        UnitProcess proc = nullptr)
        : name(nm), symbol(sym), effect(nullptr),
        mood(0), health(max_health_), max_health(max_health_),
        speed(speed_), size(size_),
        process(proc), spreads(), to_spread(0),
        provisions(0), materials(0), stories(0), money(0), fame(0),
        cycle(0), frozen(0),
        ai_target(nullptr)
    {}

    // Constructor that accepts one default item
    Unit(const char* nm, const char* sym,
        long size_, long max_health_,
        long speed_,
        const Item& default_item,
        UnitProcess proc = nullptr)
        : name(nm), symbol(sym), effect(nullptr),
        mood(0), health(max_health_), max_health(max_health_),
        speed(speed_), size(size_),
        process(proc), spreads(), to_spread(0),
        provisions(0), materials(0), stories(0), money(0), fame(0),
        cycle(0), frozen(0),
        ai_target(nullptr)
    {
        items.push_back(default_item);
    }

    // Constructor that accepts two default items
    Unit(const char* nm, const char* sym,
        long size_, long max_health_,
        long speed_,
        const Item& default_item1,
        const Item& default_item2,
        UnitProcess proc = nullptr)
        : name(nm), symbol(sym), effect(nullptr),
        mood(0), health(max_health_), max_health(max_health_),
        speed(speed_), size(size_),
        process(proc), spreads(), to_spread(0),
        provisions(0), materials(0), stories(0), money(0), fame(0),
        cycle(0), frozen(0),
        ai_target(nullptr)
    {
        items.push_back(default_item1);
        items.push_back(default_item2);
    }


    // Print basic info and items
    void info() const {
        std::cout << symbol << " " << name << "       ";
        if (health)    std::cout << "‚ù§Ô∏è HP "       << (int)health    << "/" << (int)max_health << "   ";
        if (provisions)std::cout << "üçó Food "     << (int)provisions << "   ";
        if (materials) std::cout << "ü™µ Material " << (int)materials;
        //if (size)   std::cout << "üìè size " << (int)size << " ";
        //if (speed)  std::cout << "üêæ speed " << (int)speed << " ";
        //for (auto& item : items) std::cout << item.symbol;
        std::cout << "\n";
    }
    void info_secondary() const {
        std::cout << "                  ";
        if (stories)   std::cout << "üìú Stories "  << (int)stories    << "   ";
        if (money)     std::cout << "ü™ô Money "    << (int)money     << "   ";
        if (fame)      std::cout << "üí¨ Fame "     << (int)fame;
        //if (size)   std::cout << "üìè size " << (int)size << " ";
        //if (speed)  std::cout << "üêæ speed " << (int)speed << " ";
        //for (auto& item : items) std::cout << item.symbol;
        std::cout << "\n";
    }
    void base_info() const {
        std::cout << symbol << " " << name << "       ";
        //if (health) std::cout << "‚ù§Ô∏è HP " << (int)health << "/" << (int)max_health << " ";
        //if (size)   std::cout << "üìè size " << (int)size << " ";
        //if (speed)  std::cout << "üêæ speed " << (int)speed << " ";
        //for (auto& item : items) std::cout << item.symbol;
        std::cout << "\n";
    }


    // Fight using a specific item (or bare hands if item==nullptr)
    void fight(Unit* other, Item* item) {
        if(!health && max_health) return;
        if(frozen) {
            effect = "‚ùÑÔ∏è";
            return;
        }
        if(!item || !other || !other->health /*|| other->effect*/ || !item->effect)  return;
        if(mood>0) {
           //mood--;
           effect = "üíñ";
           return;
        }
        if(other->mood>-10)
            other->mood -= 3;
        item->proficiency++;
        other->effect = item->symbol;
        item->effect(this, other);
        other->ai_target = this;
    }

    void ai_step(Terrain& terrain, long my_x, long my_y, long interpolation_step);

};

// -----------------------------------------------------------------------------
//   Items
// -----------------------------------------------------------------------------
namespace item {
    static const Item sword  { "Sword ",  "üó°Ô∏è",  "2 damage", 0, [](Unit*, Unit* other) {
        if(!other) return; 
        if(other->health>=2) other->health -= 2; else other->health = 0;}
    };
    static const Item axe    { "Axe   ",  "ü™ì",  "1 damage +2 vs larger", 0, [](Unit* owner, Unit* other) {
        if(!other) return; 
        uint8_t damage = owner->size < other->size?3:1;
        if(other->health>=damage) other->health -= damage; else other->health = 0;}
    };
    static const Item hammer { "Hammer",  "üî®",  "1 damage +3 vs undamaged +2 vs frozen", 0, [](Unit*, Unit* other) {
        if(!other) return; 
        uint8_t damage = other->health == other->max_health?4:1;
        if(other->frozen) damage += 2;
        other->frozen = 0;
        if(other->health>=damage) other->health -= damage; else other->health = 0;}
    };
    static const Item claw   { "Claw  ",   "ü©∏",  "1 damage", 0, [](Unit*, Unit* other) {
        if(!other) return; 
        if(other->health>=1) other->health -= 1; else other->health = 0;}
    }; 
    static const Item pound  { "Pound ",  "üí•",  "1 damage per 2 HP", 0, [](Unit* owner, Unit* other) {
        if(!other || !owner) return; 
        uint8_t damage = owner->health/2;
        if(other->health>=damage) other->health -= damage; else other->health = 0;}
    };
    static const Item bite   { "Bite  ",   "ü¶∑",  "2 damage, 1 HP regained", 0, [](Unit* owner, Unit* other) {
        if(!other || !owner) return; 
        if(other->health>=2) {
            other->health-=2;
            if(owner->health<owner->max_health)
                owner->health++;
        } 
        else other->health = 0;
    }};
    static void fire_damage(Unit* owner, Unit* other){
        if (!other) return;
        if (other->health >= 1) other->health--;
        else other->health = 0;
        other->effect = "üî•";
        if (other->health && !other->spreads && other->max_health>=9)
            other->spreads = fire_damage;   // self-reference works
    }
    static const Item fire   { "Fire  ",   "üî•",  "1 damage spreads through >8 max HP", 0, fire_damage};
    static const Item zap    { "Zap   ",   "‚ö°",  "4 damage and 1 to you", 0, [](Unit* owner, Unit* other) {
        if(!other || !owner) return; 
        if(other->health>=4) other->health -= 4; else other->health = 0;
        if(owner->health>=1) owner->health -= 1; else owner->health = 0;
        owner->effect = "‚ö°";
    }};
    static const Item charm { "Charm ",   "üíñ",  "reduce hostility for a bit and 1 damage to you", 0, [](Unit* owner, Unit* other) {
        if(!other || !owner) return;
        if(owner->health)
            owner->health--; 
        // deliberately allow underflows/overflows at 128
        if(other->mood<0) 
            other->mood += 10;
        else
            other->mood = 10;
    }};
    static const Item freeze { "Freeze",   "‚ùÑÔ∏è",  "immobilize for a bit and 1 damage to you", 0, [](Unit* owner, Unit* other) {
        if(!other || !owner) return;
        if(owner->health)
            owner->health--; 
        if(other->frozen<32) other->frozen += 10;
    }};
    static const Item shield { "Shield",   "üõ°Ô∏è",  "prevent damage", 0, [](Unit* owner, Unit* other) {
        owner->effect = "üõ°Ô∏è";
        if(other)
            other->effect = nullptr;
    }};
}

namespace unit {

    // ‚îÄ‚îÄ Terrain / environment
    static const Unit GRASS    ("GRASS   ", NO_SYMBOL, 0,0,0);
    static const Unit TREE2    ("TREE    ", "üå≥", 8,9,0);
    static const Unit TREE     ("TREE    ", "üå≤", 8,9,0);
    static const Unit ROCK     ("ROCK    ", "ü™®", 5,5,0);
    static const Unit WATER    ("WATER   ", "üíß", 10, 0,0);
    static const Unit MOUNTAIN ("MOUNTAIN", "‚õ∞Ô∏è", 10, 0,0);

    // ‚îÄ‚îÄ Civilized folk
    //static const Unit KNIGHT   ("KNIGHT  ", "ü§∫", 5,9,5, item::sword);
    static const Unit HUMAN    ("HUMAN   ", "üôÇ", 5,5,5, item::sword);
    static const Unit ELF      ("ELF     ", "üßù", 5,5,7);
    static const Unit DWARF    ("DWARG   ", "üßî", 3,9,3, item::hammer);
    static const Unit HALFLING ("SPRYFOLK", "üßë‚Äçü¶±", 3,3,7, item::axe);

    // ‚îÄ‚îÄ Mounts & animals
    static const Unit HORSE    ("HORSE   ", "üêé",10,5,9);
    static const Unit WOLF     ("WOLF    ", "üê∫", 6,5,10, item::bite);
    static const Unit BEAR     ("BEAR    ", "üêª", 8,5,5, item::claw);
    static const Unit EAGLE    ("EAGLE   ", "ü¶Ö", 4,5,5, item::claw);
    static const Unit UNICORN  ("UNICORN ", "ü¶Ñ",10,9,9, item::pound);
    static const Unit LION     ("LION    ", "ü¶Å",10,5,5, item::bite);
    static const Unit DOVE     ("DOVE    ", "üïäÔ∏è", 2,5,5);
    static const Unit SNAKE    ("SNAKE   ", "üêç", 3,3,5, item::bite);
    static const Unit RABBIT   ("RABBIT  ", "üêá", 1,3,10);
    static const Unit MONKEY   ("MONKEY  ", "üêí", 3,5,9, item::pound);
    static const Unit SLIME    ("SLIME   ", "ü´ß", 1,9,3);

    // ‚îÄ‚îÄ Monsters
    static const Unit ORC      ("ORC     ", "üëπ", 6,6,6, item::sword);
    static const Unit GOBLIN   ("GOBLIN  ", "üë∫", 2,3,5, item::sword);
    static const Unit TROLL    ("TROLL   ", "üßå", 7,5,2, item::hammer);
    static const Unit DRAGON   ("DRAGON  ", "üê≤",15,25,5, item::fire); // üê≤ üêâ
    static const Unit VAMPIRE  ("VAMPIRE ", "üßõ", 5,5,5, item::bite, item::charm);
    static const Unit KRAKEN   ("KRAKEN  ", "üêô",12,5,2);
    static const Unit MINOTAUR ("MINOTAUR", "üêÇ", 7,5,5, item::pound);
    static const Unit BANSHEE  ("BANSHEE ", "üëª", 5,5,5, item::charm, item::fire);

    // ‚îÄ‚îÄ Magic & undead
    static const Unit WIZARD   ("WIZARD  ", "üßô", 5,5,4, item::fire);
    static const Unit WITCH    ("WITCH   ", "üßô‚Äç‚ôÄÔ∏è", 5,5,4, item::freeze);
    static const Unit SKELETON ("SKELETON", "üíÄ", 5,3,5, item::sword);
    static const Unit ZOMBIE   ("ZOMBIE  ", "üßü", 5,5,3, item::pound);
    static const Unit DEMON    ("DEMON   ", "üòà", 8,5,5, item::fire, item::charm);
    static const Unit ARCHMAGE ("ARCHMAGE", "üîÆ", 5,5,5, item::fire, item::freeze);
    static const Unit LICH     ("LICH    ", "‚ò†Ô∏è", 5,5,5, item::fire, item::freeze);
    static const Unit GOLEM    ("GOLEM   ", "üóø",12,9,2, item::pound);
    static const Unit SHADE    ("SHADE   ", "üåë", 5,5,5, item::freeze);

    // ‚îÄ‚îÄ Sample spell-like entities
    static const Unit HEALINGLIGHT  ("Healing Light", "‚ú®",1,1,5);
    static const Unit MAGICSHIELD   ("Magic Shield",  "üõ°Ô∏è",1,1,5);
    static const Unit CURSE         ("Curse",         "‚ò†Ô∏è",1,1,5);
    static const Unit TELEPORT      ("Teleport",      "üåÄ",1,1,5);
    static const Unit TIMESTOP      ("Time Stop",     "‚è≥",1,1,5);
    static const Unit METEOR        ("Meteor",        "‚òÑÔ∏è",1,1,5);
    static const Unit CHARM         ("Charm",         "üíñ",1,1,5);
    static const Unit TORNADO       ("Tornado",       "üå™Ô∏è",6,5,5);
}

#endif // UNIT_H
